package zeno.util.intel.graphs.search;

import java.util.Iterator;
import java.util.PriorityQueue;
import java.util.Queue;

import zeno.util.intel.graphs.Heuristic;
import zeno.util.intel.graphs.Path;
import zeno.util.tools.Floats;
import zeno.util.tools.helper.Iterables;

/**
 * The {@code AStarSearch} class computes an optimal path between connected objects.
 * </br> Its efficiency is determined by the implementation of the cost and heuristic.
 * </br> A heuristic can be given either in construction or through subclassing.
 * </br> A path is generated by calling {@link #path(Object, Object)}.
 *  
 * @author Zeno
 * @since 01 Mar 2020
 * @version 1.0
 * 
 * 
 * @see <a href="http://en.wikipedia.org/wiki/A*">A* search algorithm</a>
 * @param <O>  an object type
 * @see Heuristic
 */
public class AStarSearch<O> implements Heuristic<O>
{	
	private Queue<Path<O>> queue;
	private Heuristic<O> heur;
	
	
	/**
	 * Creates a new {@code AStarSearch}.
	 * </br> Without supplying a cost function,
	 * the class methods must be overridden.
	 */
	public AStarSearch()
	{
		this(null);
	}
	
	/**
	 * Creates a new {@code AStarSearch}.
	 * 
	 * @param h  a cost cost
	 * 
	 * 
	 * @see Heuristic
	 */
	public AStarSearch(Heuristic<O> h)
	{
		heur = h;
	}
			
	/**	
	 * Generates an optimal {@code Path}.
	 * 
	 * @param src  a source object
	 * @param tgt  a target object
	 * @return  an optimal path
	 * 
	 * 
	 * @see Path
	 */
 	public Path<O> path(O src, O tgt)
	{
		queue = Queue(src);
		queue.add(new Path<>(src));
		
		// While open paths are available...
		while(!queue.isEmpty())
		{
			// Check the shortest estimate.
			Path<O> pCurr = queue.poll();
			
			// If it reaches the destination...
			if(pCurr.endsAt(tgt))
			{
				// It is the solution.
				return pCurr;
			}

			// Otherwise, consider the next steps.
			for(O next : neighbours(pCurr.Target()))
			{
				// If the step does not create a loop...
				if(!pCurr.reaches(next))
				{
					// Use it to create a new path.
					Path<O> pNew = new Path<>(pCurr, next);
					
					// If the path is valid...
					if(validate(pNew))
					{
						// Add it to the open paths.
						queue.add(pNew);
					}
				}
			}
		}
		
		// Otherwise, no solution is found.
		return null;
	}
	
 	
 	private boolean validate(Path<O> p)
 	{
 		Iterator<Path<O>> iter = queue.iterator();
 		
 		// For every path in the open set...
 		while(iter.hasNext())
 		{
 			Path<O> pOld = iter.next();
 			Path<O> pSub = pOld.truncate(p.Target());
 			
 			// If it passes through the target object...
 			if(pSub != null)
 			{
 				// And it is less efficient...
				if(p.cost(this) < pSub.cost(this))
				{
					// Remove the path.
					iter.remove();
					// The new path is valid.
					return true;
				}
				
				// Otherwise, the new path is invalid.
				return false;
 			}
 		}
 		
 		// Otherwise, the new path is valid.
 		return true;
 	}
  	
 	private Queue<Path<O>> Queue(O tgt)
	{
		return new PriorityQueue<>
		(
			(Path<O> p, Path<O> q) ->
			{
				return (int) Floats.sign
				(
					p.cost(this) + estimate(p.Target(), tgt)
					-
					q.cost(this) - estimate(q.Target(), tgt)
				);
			}
		);
	}
	
 	
	@Override
	public Iterable<O> neighbours(O obj)
	{
		if(heur != null)
		{
			return heur.neighbours(obj);
		}
		
		return Iterables.empty();
	}
	
	@Override
	public float estimate(O src, O tgt)
	{
		if(heur != null)
		{
			return heur.estimate(src, tgt);
		}
		
		return 0f;
	}
	
	@Override
	public float cost(O src, O tgt)
	{
		if(heur != null)
		{
			return heur.cost(src, tgt);
		}
		
		return 0f;
	}
}